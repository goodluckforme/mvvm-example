<resources>
    <string name="app_name">Coroutines</string>
    <string name="simple">
        "private fun simpleTest() = GlobalScope.launch(Dispatchers.Main) {\n"
        "        async(Dispatchers.IO) {\n"
        "            result.addString(\"执行等待 5S前 \\n\", sb)\n"
        "            delay(2000)\n"
        "            //延迟5秒后下面的不执行\n"
        "            result.addString(\"执行等待 5S后 \\n\", sb)\n"
        "        }.await()\n"
        "        //没有await 会直接向下执行\n"
        "        result.addString(\"等待异步线程执行结束\", sb)\n"
        "        progressbar.hide()\n"
        "    }"
    </string>
    <string name="excute">执行</string>
    <string name="delayTest">
        "    fun delayTest() = runBlocking {\n"
        "        // 使用协程\n"
        "        result.addString(\"Coroutines: start\\n\", sb)\n"
        "        val jobs = List(100_000) {\n"
        "            // 创建新的coroutine\n"
        "            GlobalScope.launch {\n"
        "                // 挂起当前上下文而非阻塞1000ms\n"
        "                delay(1000L)\n"
        "                println(\".\" Thread.currentThread().name)\n"
        "            }\n"
        "        }\n"
        "        //Suspend function 'join' should be called only from a coroutine or another suspend function\n"
        "        jobs.forEach { it.join() }\n"
        "        result.addString(\"Coroutines: end\\n\", sb)\n"
        "    }"
    </string>
    <string name="delayTest2">
        "fun delayTest2() {\n"
        "        delayTestResult.addString(\"No Coroutines: start\\n\", sb)\n"
        "        // 使用阻塞\n"
        "        val noCoroutinesJobs = List(100) {\n"
        "            // 创建新的线程\n"
        "            Thread {\n"
        "                // 阻塞\n"
        "                Thread.sleep(1000L)\n"
        "                delayTestResult.addString(\".\"  Thread.currentThread().name  \"\\n\", sb)\n"
        "            }\n"
        "        }\n"
        "        noCoroutinesJobs.forEach { it.join() }\n"
        "        delayTestResult.addString(\"No Coroutines: end\\n\", sb)\n"
        "    }"
    </string>
    <string name="runblock">
        "//解决 join报错 ：Suspend function 'join' should be called only from a coroutine or another suspend function\n"
        "    fun runBlockingTest() = runBlocking{\n"
        "        val job = launch {\n"
        "            // 挂起1000ms  界面卡主1w秒\n"
        "            delay(10000L)\n"
        "        }\n"
        "        // 接口含义同Thread.join只是这里是`suspension`\n"
        "        job.join()\n"
        "    }"
    </string>
    <string name="asyncTest">
        "fun asyncTest() = runBlocking {\n"
        "        // 计算总共需要执行多久，measureTimeMillis是kotlin标准库中所提供的方法\n"
        "        val time = measureTimeMillis {\n"
        "            val one = async(Dispatchers.IO) { doOne() } // 这里将doOne抛到CommonPool中的线程执行，并在结束时将结果带回来。\n"
        "            val two = async(Dispatchers.IO) { doTwo() } // 这里将doTwo抛到CommonPool中的线程执行，并在结束时将结果带回来。\n"
        "            asyncTestResult.addString(\"The answer is ${one.await()  two.await()}\", sb) // 这里会输出6\n"
        "        }\n"
        "        asyncTestResult.addString(\"\\t总耗时${time}ms\", sb) // 由于doOne与doTwo在异步执行，因此这里输出大概是700ms\n"
        "        progressbar.hide()\n"
        "    }\n"
        "    suspend fun doOne() : Int {\n"
        "        delay(500L)\n"
        "        return 1\n"
        "    }\n"
        "    suspend fun doTwo() : Int {\n"
        "        delay(700L)\n"
        "        return 5\n"
        "    }"
    </string>
    <string name="jobTest">"fun jobTest() = runBlocking {\n"
        "        // 创建一个运行在CommonPool线程池中的Coroutine\n"
        "        val request = launch() {\n"
        "            // 创建一个运行在CommonPool线程池中的coroutine\n"
        "            val job1 = launch {\n"
        "                jobTestResult.addString(\"job1: I have my own context and execute independently!\\n\", sb)\n"
        "                delay(1000)\n"
        "                jobTestResult.addString(\"job1: I am not affected by cancellation of the request\\n\", sb)\n"
        "            }\n"
        "            // 创建一个运行在父CoroutineContext上的coroutine\n"
        "            val job2 = launch(coroutineContext) {\n"
        "                jobTestResult.addString(\"job2: I am a child of the request coroutine\\n\", sb)\n"
        "                delay(1000)\n"
        "                jobTestResult.addString(\"job2: I will not execute this line if my parent request is cancelled\\n\", sb)\n"
        "            }\n"
        "\n"
        "        }\n"
        "        //只有等上面执行完才能执行下面\n"
        "        //request.join()\n"
        "        delay(500)\n"
        "        request.cancel() // 取消\n"
        "        delay(1000) // delay a second to see what happens\n"
        "        jobTestResult.addString(\"main: Who has survived request cancellation?\\n\", sb)\n"
        "        progressbar.hide()\n"
        "    }</string>
    <string name="safeTest">
        " safeTest.setOnClickListener {\n" 
        "            progressbar.canLoad {\n" 
        "                resetSb { sb ->\n" 
        "                    this@MainActivity.sb = sb\n" 
        "                    safeTestResult.text = sb.toString()\n" 
        "                }\n" 
        "                //线程安全\n" 
        "                //在CommonPool线程池中执行coutner自增\n" 
        "                massiveRun(safeTestResult, Dispatchers.IO) {\n" 
        "                    //每次我们都自增一次coutiner\n" 
        "                    //方式三\n" 
        "                    //synchronized(lock) {\n" 
        "                    //    counter\n" 
        "                    //}\n" 
        "                    //方式二\n" 
        "                    //mutex.lock()\n" 
        "                    //try { counter }\n" 
        "                    //finally { mutex.unlock() }\n" 
        "                    counter.incrementAndGet()\n" 
        "                }\n" 
        "                safeTestResult.addString(\"Counter = $counter\", sb)\n" 
        "                progressbar.hide()\n" 
        "            }\n" 
        "        }\n" 
        "\n" 
        "        fun massiveRun(textView: TextView, context: CoroutineContext, action: suspend () -> Unit) = runBlocking {\n" 
        "            val n = 1000 // launch的个数\n" 
        "            val k = 1000 // 每个coroutine中执行action的次数\n" 
        "            val time = measureTimeMillis {\n" 
        "                val jobs = List(n) {\n" 
        "                    launch(context) {\n" 
        "                        repeat(k) {\n" 
        "                            action()\n" 
        "                        }\n" 
        "                    }\n" 
        "                }\n" 
        "                jobs.forEach {\n" 
        "                    it.join()\n" 
        "                }\n" 
        "            }\n" 
        "            textView.addString(\"Completed ${n * k} actions in $time ms\", sb)\n" 
        "        }"
    </string>
    <string name="actorTest">
        "fun actor() = runBlocking {\n"
        "            // 这个方法启动一个新的Counter Actor\n"
        "            fun counterActor() = actor<![CDATA[<CounterMsg>]]>(Dispatchers.IO) {\n"
        "                var counter = 0\n"
        "                for (msg in channel) { // 不断接收channel中的数据，这个channel是ActorScope的变量\n"
        "                    when (msg) {\n"
        "                        is IncCounter -> counter // 如果是IncCounter类型，我们就自增\n"
        "                        is GetCounter -> msg.response.complete(counter) // 如果是GetCounter类型，我们就带回结果\n"
        "                    }\n"
        "                }\n"
        "            }\n"
        "\n"
        "            val counter = counterActor() // 创建一个Actor\n"
        "            massiveRun(actorTestResult, Dispatchers.IO) {\n"
        "                counter.send(IncCounter) // action发送自增类型，使得不断执行action不断的触发自增\n"
        "            }\n"
        "            // 创建一个CompletableDeferred用于带回结果\n"
        "            val response = CompletableDeferred<![CDATA[<Int>]]>()\n"
        "            counter.send(GetCounter(response)) // 发送GetCounter类型带回结果\n"
        "            actorTestResult.addString(\"Counter = ${response.await()}\", sb) // 输出结果\n"
        "            counter.close() // 关闭actor\n"
        "            progressbar.hide()\n"
        "\n"
        "        }\n"
        "        fun massiveRun(textView: TextView, context: CoroutineContext, action: suspend () -> Unit) = runBlocking {\n"
        "            val n = 1000 // launch的个数\n"
        "            val k = 1000 // 每个coroutine中执行action的次数\n"
        "            val time = measureTimeMillis {\n"
        "                val jobs = List(n) {\n"
        "                    launch(context) {\n"
        "                        repeat(k) {\n"
        "                            action()\n"
        "                        }\n"
        "                    }\n"
        "                }\n"
        "                jobs.forEach {\n"
        "                    it.join()\n"
        "                }\n"
        "            }\n"
        "            textView.addString(\"Completed ${n * k} actions in $time ms\", sb)\n"
        "        }"
    </string>
    <string name="channelTest">
        " suspend fun player(name: String, table: Channel<![CDATA[<Ball>]]>) {\n"
        "        for (ball in table) { // 不断接球\n" 
        "            ball.hits++ \n"
        "            println(\"$name $ball\")\n" 
        "            delay(300) // 等待300ms\n" 
        "            table.send(ball) // 发球\n" 
        "        }\n" 
        "    }\n" 
        "\n" 
        "    fun channelTest() = runBlocking {\n" 
        "        val table = Channel<![CDATA[<Ball>]]>() // 创建一个channel作为桌子\n"
        "        launch(coroutineContext) { player(\"ping\", table) } // 选手一，先接球中\n" 
        "        launch(coroutineContext) { player(\"pong\", table) } // 选手二，也开始接球\n" 
        "        table.send(Ball(0)) // 开球，发出第5个球\n"
        "        delay(5000) // 打一秒钟\n"
        "        table.receive() // 接球，终止在player中的循环发球\n" 
        "    }"
    </string>
    <string name="producerTest">
        " fun producerTest() = runBlocking<![CDATA[<Unit>]]> {\n"
        "        // 创建一个生产者方法\n"
        "        // 得到生产者\n"
        "        val squares = produce<![CDATA[<Int>]]> {\n"
        "            for (x in 1..5) send(x * x)\n"
        "        }\n"
        "        // 对生产者生产的每一个结果进行消费\n"
        "        squares.consumeEach {\n"
        "            println(it)\n"
        "        }\n"
        "    }\n"
    </string>
    <string name="pipelineTest">
        " fun pipelineTest() = runBlocking<![CDATA[<Unit>]]> {\n"
        "        // 创建一个生产者，返回的是一个ProducerJob\n"
        "        fun produceNumbers() = produce<![CDATA[<Int>]]> {\n"
        "            var x = 1\n"
        "            while (true) send(x) // infinite stream of integers starting from 1\n"
        "        }\n"
        "\n"
        "        // 创建一个用于加工生产者的生产者（ProducerJob是继承自ReceiveChannel)\n"
        "        fun square(numbers: ReceiveChannel<![CDATA[<Int>]]>) = produce<![CDATA[<Int>]]> {\n"
        "            for (x in numbers) send(x * x)\n"
        "        }\n"
        "\n"
        "        val numbers = produceNumbers() // 生产者\n"
        "        val squares = square(numbers) // 加工\n"
        "        for (i in 1..5) pipelineTestResult.addString(\"${squares.receive()}\", sb) // 消费前5个结果\n"
        "\n"
        "        squares.cancel() // cancel加工的coroutine（一般来说是不用主动cancel的，因为协程就好像一个常驻线程，挂起也会被其他任务使用闲置资源，不过大型应用推荐cancel不使用的coroutine)\n"
        "        numbers.cancel() // cancel生产者的coroutine\n"
        "    }"
    </string>
    <string name="selectTest">
        "fun selectTest() = runBlocking {\n" 
        "        // 每300ms发送一个channel1\n" 
        "        fun channel1(context: CoroutineContext) = produce<![CDATA[<String>]]>(context) {\n"
        "            while (true) {\n" 
        "                delay(300)\n" 
        "                send(\"channel1\")\n" 
        "            }\n" 
        "        }\n" 
        "\n" 
        "        // 每100ms发送一个channel2\n" 
        "        fun channel2(context: CoroutineContext) = produce<![CDATA[<String>]]>(context) {\n"
        "            while (true) {\n" 
        "                delay(100)\n" 
        "                send(\"channel2\")\n" 
        "            }\n" 
        "        }\n" 
        "\n" 
        "        // 每次选择先到达的一个\n" 
        "        suspend fun selectFirstChannel(channel1: ReceiveChannel<![CDATA[<String>]]>, channel2: ReceiveChannel<![CDATA[<String>]]>) {\n"
        "            select<![CDATA[<Unit>]]> {\n"
        "                // 这里的<![CDATA[<Unit>]]>说明这个select没有产生任何返回值\n"
        "                channel1.onReceive { value ->\n" 
        "                    selectTestResult.addString(value,sb)\n" 
        "                }\n" 
        "                channel2.onReceive { value ->\n" 
        "                    selectTestResult.addString(value,sb)\n" 
        "                }\n" 
        "            }\n" 
        "        }\n" 
        "\n" 
        "        val channel1 = channel1(coroutineContext)\n" 
        "        val channel2 = channel2(coroutineContext)\n" 
        "        repeat(5) {\n" 
        "            selectFirstChannel(channel1, channel2)\n" 
        "        }\n" 
        "    }"
    </string>
</resources>
